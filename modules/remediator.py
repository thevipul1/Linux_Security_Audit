# Paste the remediator.py content from above
import os
import logging
import subprocess
from modules.utils import run_command

class RemediationEngine:
    def __init__(self, dry_run=False):
        self.dry_run = dry_run
        self.logger = logging.getLogger(__name__)
    
    def apply_fixes(self, scan_results=None):
        """Apply remediation fixes based on scan results"""
        if self.dry_run:
            self.logger.info("=== DRY RUN MODE - No changes will be applied ===")
        
        fixes_applied = []
        
        # If no scan results provided, create a basic remediation script
        if not scan_results:
            self.logger.warning("No scan results provided, generating basic hardening script")
            self.generate_basic_hardening()
            return fixes_applied
        
        # Apply fixes based on scan results
        for result in scan_results:
            if result.get('status') in ['FAIL', 'WARN'] and result.get('remediation'):
                fixes_applied.append(self.apply_fix(result))
        
        return fixes_applied
    
    def apply_fix(self, result):
        """Apply a single fix"""
        remediation_script = result.get('remediation')
        
        if not os.path.exists(remediation_script):
            self.logger.error(f"Remediation script not found: {remediation_script}")
            return False
        
        self.logger.info(f"Applying fix for: {result['title']}")
        self.logger.info(f"Script: {remediation_script}")
        
        if self.dry_run:
            self.logger.info(f"DRY RUN: Would execute {remediation_script}")
            return True
        
        try:
            # Make script executable
            os.chmod(remediation_script, 0o755)
            
            # Execute the remediation script
            exit_code, stdout, stderr = run_command(f"sudo {remediation_script}")
            
            if exit_code == 0:
                self.logger.info(f"✅ Successfully applied fix for {result['title']}")
                return True
            else:
                self.logger.error(f"❌ Failed to apply fix for {result['title']}: {stderr}")
                return False
                
        except Exception as e:
            self.logger.error(f"❌ Error applying fix for {result['title']}: {e}")
            return False
    
    def generate_basic_hardening(self):
        """Generate a basic hardening script if no scan results available"""
        basic_script = """#!/bin/bash
# Basic System Hardening Script
# Generated by Linux Security Audit Tool

set -e
echo "Starting basic system hardening..."

# Update system
echo "Updating system packages..."
apt update && apt upgrade -y

# Enable UFW firewall
echo "Configuring firewall..."
ufw --force reset
ufw default deny incoming
ufw default allow outgoing
ufw allow ssh
ufw --force enable

# Install security tools
echo "Installing security tools..."
apt install -y unattended-upgrades fail2ban auditd

# Configure automatic updates
echo "Configuring automatic updates..."
sed -i 's|//Unattended-Upgrade::Remove-Unused-Dependencies "false";|Unattended-Upgrade::Remove-Unused-Dependencies "true";|' /etc/apt/apt.conf.d/50unattended-upgrades

echo "Basic hardening completed!"
"""

        script_path = "remediations/basic_hardening.sh"
        os.makedirs("remediations", exist_ok=True)
        
        with open(script_path, "w") as f:
            f.write(basic_script)
        
        os.chmod(script_path, 0o755)
        self.logger.info(f"Generated basic hardening script: {script_path}")
        
        if not self.dry_run:
            self.logger.info("To apply basic hardening, run: sudo ./remediations/basic_hardening.sh")
